# remote 一个ssh管理工具

remote是一个ssh远程连接管理工具。当我们使用远程服务器时，现有的cli工具使用起来非常繁琐，remote通过提供更高层次的cli工具抽象来辅助用户使用远程服务器。

现有的很多计算机集群使用docker来管理资源分配，这种镜像化管理非常方便，但是对于一些个性化配置的需求会较为麻烦。我们可能遇到如下问题：

- 如何便捷配置ssh免密登录
- 如何便捷同步本地主机的一些配置文件
- 如何管理第一次连接时的初始化行为（安装一些必须的包，配置一些个性化环境变量到zshrc或bashrc中而不是直接替换配置文件）
- 如何解决远程集群代理问题？（一些方法可以通过本地主机网络中转的方式，来绕靠远程无法使用代理的限制）
- 如何将本地下载的文件便捷上传到远程？（scp指令极其繁琐）
- 如何快速同步远程和本地的文件？（比如使用rsync）
- 如何管理ssh连接（比原生ssh强大的方式）


## MVP设计

我们首先完成bootstrap的设计，但是bootstrap实际上并不只是一个初始化工具，而是一个sync工具。

初步的可以划分为三类别：
1. 脚本的执行
2. 文件同步
3. 文件文本块同步

脚本执行使用文件管理可执行脚本，目前只支持.sh文件，且需要内部写好执行器等价于 source script.sh
文件同步有多种设置：
- 本地覆盖远程
- 远程覆盖本地
- 时间戳优先（使用时间戳更新的版本同步远程和本地）
- 本地时间戳优先（本地时间戳更新能覆盖远程，远程不能覆盖本地）
- 远程时间戳优先

文件文本块同步，类似于conda init，通过再bashrc等文件中插入一个具有特定注释标识头和标识尾来确认文本块位置。
文本块由多个文本块组成，类似于脚本模块。例如alias可以写在一个sh文件中，proxy配置写在一个文件中，配置文件中需要写清楚拼接顺序。
rmt会自动管理时间戳校准和hash校验。

由于脚本执行和文件同步的逻辑实际上是两个应用场景。文件同步一般是配置文件等的同步，而脚本执行中也可能产生一些需要同步到本地的文件比如key。但是这种和文件同步的性质不一样。
因此我们允许脚本执行的过程中通过设置环境变量的形式来传递文件路径。也就是说每个脚本执行模块，我们允许用户在其中定义变量后，执行完后，rmt来处理一些本地以及远程需要交互的内容。


上述是我们的设计逻辑，可以实现一个较好的框架抽象设计。下面是一些具体使用例子。
1. 免密登录设置。脚本执行并通过环境变量指定文件同步。
2. bashrc个性配置，使用文本块同步
3. 必要包安装，使用脚本执行来实现



文件同步选项
cover 覆盖
sync 时间戳同步
update 仅依赖一侧时间戳
init 只有第一次初始化时覆盖

:表示远程目录 常规表示本地目录
src = "~/.bashrc"
dist = ":~/.bashrc"
mode = "sync"

文本块同步
src = [
  "~/alias.sh",
  "~/proxy.sh",
  "~/export.sh",
]
dist = ":~/.zshrc"
mode = "init"

init 第一次初始化时执行
update 每次都增量更新，不删除旧的模块
cover 每次直接覆盖

脚本执行
[[script]]
src = "~/install.sh"
args = ["--help"]
run = "always"

always 每次sync都执行
init 第一次执行


```toml
host = "127.0.0.1"
user = "root"
port = 22
password = "123456"


# ========== FILE SYNC ==========
[[file]]
src = "~/.bashrc"
dist = ":~/.bashrc"
mode = "sync"

[[file]]
src = "./local_config/nvim"
dist = ":~/.config/nvim"
mode = "update"


# ========== BLOCK SYNC ==========
[[block]]
src = ["~/alias.sh", "~/proxy.sh", "~/export.sh"]
dist = ":~/.zshrc"
mode = "init"


# ========== SCRIPT EXECUTION ==========
[[script]]
src = "~/install.sh"
args = ["-i", "--help"]
run = "init"

```



